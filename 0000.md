# AI Terminal - Fixes and Improvements Tracking

## Issues Identified and Fixes Applied

### 1. Plugin System Fixes

#### Problem: Plugin Interface Inconsistency
- **Issue**: Plugin manager expected `command` and `handler` properties, but plugins use `pattern` and `execute`
- **Fix Required**: Update plugin manager to use correct property names

#### Problem: Missing `plugins` property in PluginManager
- **Issue**: automation_engine.js expects `pluginManager.plugins.values()` but this property doesn't exist
- **Fix Required**: Add Map to store plugins by name

#### Problem: Incorrect method name
- **Issue**: command_executor.js calls `findPluginForCommand` but plugin manager has `findCommandHandler`
- **Fix Required**: Rename method to match usage

#### Problem: Plugin execution method mismatch
- **Issue**: Plugin manager's `executePluginCommand` calls `handler` instead of `execute`
- **Fix Required**: Update to call `execute` method

### 2. AI Service Issues

#### Problem: Response parser reference
- **Issue**: ai_service.js assigns module directly to `this.responseParser`, but automation_engine.js uses it as if it were an instance
- **Fix Required**: Create proper instance or update usage

### 3. Automation Engine Issues

#### Problem: Incorrect regex match handling
- **Issue**: Several methods have `match && match` instead of `match && match[1]`
- **Fix Required**: Update to access proper regex match groups

#### Problem: isCommonCommand method
- **Issue**: Splits input to array but doesn't extract first element for comparison
- **Fix Required**: Use `input.split(' ')[0]` instead of the entire array

### 4. Missing Methods in PluginManager

#### Problem: Expected methods not implemented
- **Issue**: main.js expects `getAvailablePlugins()`, `enablePlugin()`, `disablePlugin()` but they don't exist
- **Fix Required**: Implement these methods

### 5. Security Issues

#### Problem: Weak dangerous command detection
- **Issue**: Only covers a few patterns, doesn't properly sanitize inputs
- **Fix Required**: Expand security validation

### 6. Performance and Architecture Issues

#### Problem: No command recognition bypass
- **Issue**: Every input triggers AI API call (expensive, slow)
- **Fix Required**: Add direct command recognition for basic shell commands

#### Problem: Missing caching mechanisms
- **Issue**: No caching for common commands or responses
- **Fix Required**: Add caching layer

#### Problem: Missing request debouncing
- **Issue**: Rapid inputs cause API spam
- **Fix Required**: Add request throttling/debouncing

## Priority Fixes to Apply

### 1. Plugin Manager Fix
```javascript
// plugin_manager.js - Updated version
const fs = require('fs').promises;
const path = require('path');

class PluginManager {
  constructor(commandExecutor) {
    this.commandExecutor = commandExecutor;
    this.pluginsDirectory = path.join(__dirname, 'plugins');
    this.commandRegistry = []; // A simple array to hold all command objects
    this.plugins = new Map(); // Store plugins by name
    this.enabledPlugins = new Set(); // Track enabled plugins
  }

  /**
   * Load all plugins from the plugins directory.
   */
  async loadPlugins() {
    try {
      const pluginFiles = await fs.readdir(this.pluginsDirectory);
      
      for (const file of pluginFiles) {
        if (file.endsWith('.js')) {
          try {
            const pluginPath = path.join(this.pluginsDirectory, file);
            const PluginClass = require(pluginPath);
            const pluginInstance = new PluginClass(this.commandExecutor);
            
            if (typeof pluginInstance.getCommands === 'function' && typeof pluginInstance.getName === 'function') {
              const pluginName = pluginInstance.getName();
              const commands = pluginInstance.getCommands();
              
              // Store the plugin instance
              this.plugins.set(pluginName, pluginInstance);
              this.enabledPlugins.add(pluginName);
              
              commands.forEach(cmd => {
                // Store the command with the plugin instance
                this.commandRegistry.push({ ...cmd, plugin: pluginInstance });
              });
              console.log(`Loaded plugin: ${file} with ${commands.length} commands`);
            } else {
                console.warn(`Plugin ${file} does not have required methods (getName, getCommands).`);
            }
          } catch (error) {
            console.error(`Failed to load plugin ${file}:`, error);
          }
        }
      }
    } catch (error) {
      console.error('Error loading plugins:', error);
    }
  }

  /**
   * Find a plugin command for the given input string.
   * @param {string} input - The user's input string.
   * @returns {Object|null} The matched command info, or null.
   */
  findPluginForCommand(input) {
    for (const cmd of this.commandRegistry) {
      if (cmd.pattern) { // Use pattern instead of command
        const match = input.match(cmd.pattern);
        if (match) {
          return {
            command: cmd,           // The command object with execute function
            match: match,           // The result of the regex match
            plugin: cmd.plugin      // The plugin instance
          };
        }
      }
    }
    return null;
  }

  /**
   * Execute a plugin command.
   * @param {Object} commandInfo - The command info from findPluginForCommand.
   * @returns {Promise<Object>} The result of the plugin execution.
   */
  async executePluginCommand(commandInfo) {
    const { command, match, plugin } = commandInfo;
    try {
      // Call the execute function instead of handler
      return await command.execute(match);
    } catch (error) {
      console.error(`Error executing plugin command:`, error);
      return {
        success: false,
        output: `Plugin error: ${error.message}`,
      };
    }
  }
  
  /**
   * Get available plugins
   */
  getAvailablePlugins() {
    const plugins = [];
    for (const [name, plugin] of this.plugins) {
      plugins.push({
        name: name,
        enabled: this.enabledPlugins.has(name),
        commands: plugin.getCommands().map(cmd => ({
          name: cmd.name || 'unnamed',
          description: cmd.description || 'No description'
        }))
      });
    }
    return plugins;
  }
  
  /**
   * Enable a plugin
   */
  enablePlugin(pluginName) {
    if (this.plugins.has(pluginName)) {
      this.enabledPlugins.add(pluginName);
      return { success: true, message: `Plugin ${pluginName} enabled` };
    }
    return { success: false, message: `Plugin ${pluginName} not found` };
  }
  
  /**
   * Disable a plugin
   */
  disablePlugin(pluginName) {
    if (this.enabledPlugins.has(pluginName)) {
      this.enabledPlugins.delete(pluginName);
      return { success: true, message: `Plugin ${pluginName} disabled` };
    }
    return { success: false, message: `Plugin ${pluginName} not found or already disabled` };
  }
}

module.exports = PluginManager;
```

### 2. Fix in Automation Engine - isCommonCommand method
```javascript
// In automation_engine.js
isCommonCommand(input) {
  const commonCommands = [
    'ls', 'cd', 'pwd', 'mkdir', 'touch', 'rm', 'cp', 'mv', 'echo', 'cat', 'grep', 'find', 'man', 'ps', 'kill', 'top', 'df', 'du', 'chmod', 'chown', 'ssh', 'scp', 'ftp', 'wget', 'curl', 'ping', 'netstat', 'ifconfig', 'ip', 'route', 'uname', 'history', 'clear', 'exit'
  ];
  const command = input.split(' ')[0]; // Get the first word as the command
  return commonCommands.includes(command);
}
```

### 3. Fix in Automation Engine - methods with incorrect regex matching
```javascript
// In handlePackageInstall method
async handlePackageInstall(input, rule) {
  const match = input.match(rule.pattern);
  const packageManager = match && match[1] ? match[1].toLowerCase() : '';
  const packageName = match && match[2] ? match[2] : '';

  const commands = {
    npm: `npm install ${packageName}`,
    pip: `pip install ${packageName}`,
    apt: `sudo apt-get install -y ${packageName}`,
    brew: `brew install ${packageName}`
  };

  const command = commands[packageManager] || `npm install ${packageName}`;
  
  return {
    success: true,
    commandSequences: [{
      id: `install-${packageName}`,
      rank: 1,
      commands: [command],
      description: `Install ${packageName} using ${packageManager}`
    }]
  };
}

// In handleFileCreation method
async handleFileCreation(input, rule) {
  const match = input.match(rule.pattern);
  const filename = match && match[1] ? match[1] : '';  // Fixed: access first capture group
  
  // Generate AI-powered file content based on filename extension
  const extension = path.extname(filename).toLowerCase();
  const content = await this.generateFileContent(filename, extension);

  return {
    success: true,
    commandSequences: [{
      id: `create-${filename}`,
      rank: 1,
      commands: [`touch ${filename}`],
      description: `Create file ${filename}`,
      fileContent: content
    }]
  };
}

// In handleNavigation method
async handleNavigation(input, rule) {
  const match = input.match(rule.pattern);
  const targetDir = match && match[1] ? match[1] : '';  // Fixed: access first capture group

  return {
    success: true,
    commandSequences: [{
      id: `nav-${targetDir}`,
      rank: 1,
      commands: [`cd ${targetDir}`],
      description: `Navigate to ${targetDir}`
    }]
  };
}

// In handleCodeGeneration method
async handleCodeGeneration(input, rule) {
  const match = input.match(rule.pattern);
  const language = match && match[1] ? match[1].toLowerCase() : '';  // Fixed: access first capture group
  const description = match && match[2] ? match[2] : '';  // Fixed: access second capture group
  
  const filename = `script-${Date.now()}.${this.getLanguageExtension(language)}`;
  const content = await this.generateCodeContent(language, description);

  return {
    success: true,
    commandSequences: [{
      id: `code-${filename}`,
      rank: 1,
      commands: [`touch ${filename}`],
      description: `Generate ${language} code for ${description}`,
      fileContent: content
    }]
  };
}
```

### 4. Enhanced Security in CommandExecutor
```javascript
isDangerous(command) {
  const dangerousPatterns = [
    /^sudo\s+rm\s+-rf\s+\//,      // Dangerous rm -rf with sudo
    /^rm\s+-rf\s+\//,              // Dangerous rm -rf
    />\s*\/dev\/sd/,               // Overwriting device files
    /.*>&\s*\/dev\/null\s*\|\s*rm.*/, // Redirect output to rm command
    /.*\|\s*rm\s+-rf.*/,           // Piping to dangerous commands
    /.*&&\s*rm\s+-rf.*/,           // Chaining dangerous commands
    /.*;\s*rm\s+-rf.*/,            // Semicolon separation for dangerous commands
    /\/\.\.\//,                    // Path traversal attempts
    /.*\$\(.+\).*/,                // Command substitution attempts
    /.*`.*`/,                      // Backtick command execution
    /.*\{\s*\/.*\s*\}.*/,          // Globbing attacks
  ];
  
  // Also check for dangerous file paths
  if (command.includes('../../') || command.includes('../../../')) {
    return true;
  }
  
  return dangerousPatterns.some(pattern => pattern.test(command));
}
```

### 5. AI Service Response Parser Fix
```javascript
// In ai_service.js line 73, the responseParser property should be fine as-is since
// it's used in automation_engine.js, but we need to make sure both approaches work:
// Option 1: Keep as module import and use in automation_engine.js as static method
// Option 2: Create instance (current approach should work)
```

The current approach with `this.responseParser = require('./ai_response_parser');` should work since it's being called as `this.responseParser.parseResponse()` which looks for the method on the imported module. This is valid Node.js behavior.

## Additional Improvements Needed

### 1. Command Recognition Bypass
Add a method to check if an input is a direct shell command before sending to AI.

### 2. Caching Layer
Implement caching for common command sequences.

### 3. Request Debouncing
Add throttling for rapid inputs to prevent API spam.

### 4. MCP Integration
Add Model Context Protocol server integration as mentioned in the plans.

### 5. Enhanced Error Handling
Add better error handling throughout the application.

### 6. Memory Management
Add cleanup mechanisms for Maps/Sets to prevent memory leaks.

## Completed Implementation Status

All the major issues identified have been documented with the specific fixes needed. The next step is to apply these fixes to the actual code files.